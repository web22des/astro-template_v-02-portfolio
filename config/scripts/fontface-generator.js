#!/usr/bin/env node
import fs from "fs/promises";
import path from "path";
import { glob } from "glob";

// --- –ö–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—è ---
const CONFIG = {
    // –ü–∞–ø–∫–∞ —Å –∏—Å—Ö–æ–¥–Ω—ã–º–∏ —à—Ä–∏—Ñ—Ç–∞–º–∏ (–º–æ–∂–µ—Ç –±—ã—Ç—å –∏–∑–º–µ–Ω–µ–Ω–∞)
    FONTS_DIR: path.join(process.cwd(), "public", "fonts"),
    // –í—ã—Ö–æ–¥–Ω–æ–π SCSS-—Ñ–∞–π–ª
    OUTPUT_FILE: path.join(process.cwd(), "src", "styles", "fonts", "fonts.scss"),
    // –ü–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ–º—ã–µ —Ñ–æ—Ä–º–∞—Ç—ã —à—Ä–∏—Ñ—Ç–æ–≤ (–≤—Å–µ –≤–∞—Ä–∏–∞–Ω—Ç—ã —Ä–µ–≥–∏—Å—Ç—Ä–∞)
    SUPPORTED_EXTENSIONS: [".woff2", ".WOFF2", ".woff", ".WOFF", ".ttf", ".TTF", ".otf", ".OTF"],
    // –ü–∞—Ä–∞–º–µ—Ç—Ä—ã –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é –¥–ª—è @font-face
    DEFAULT_FONT_PROPS: {
        display: "swap",
        unicodeRange: null, // –í–æ–∑–º–æ–∂–Ω–æ—Å—Ç—å —É–∫–∞–∑–∞—Ç—å, –∫–∞–∫–∏–µ –∫–æ–Ω–∫—Ä–µ—Ç–Ω–æ Unicode-—Å–∏–º–≤–æ–ª—ã –¥–æ–ª–∂–µ–Ω –∑–∞–≥—Ä—É–∂–∞—Ç—å –¥–∞–Ω–Ω—ã–π —à—Ä–∏—Ñ—Ç
    },
};

// --- –£–ª—É—á—à–µ–Ω–Ω–æ–µ –ª–æ–≥–∏—Ä–æ–≤–∞–Ω–∏–µ ---
const logger = {
    info: (msg) => console.log(`[Font Generator] ‚ÑπÔ∏è ${msg}`),
    debug: (msg) => process.env.DEBUG && console.log(`[Font Generator] üîç ${msg}`),
    success: (msg) => console.log(`[Font Generator] ‚úÖ ${msg}`),
    warn: (msg) => console.log(`[Font Generator] ‚ö†Ô∏è ${msg}`),
    error: (msg) => console.error(`[Font Generator] ‚ùå ${msg}`),
};

// --- –û—Å–Ω–æ–≤–Ω–∞—è —Ñ—É–Ω–∫—Ü–∏—è ---
async function generateFontFaces() {
    try {
        logger.info("Starting font face generation...");
        logger.debug(`Current working directory: ${process.cwd()}`);
        logger.debug(`Resolved fonts directory: ${CONFIG.FONTS_DIR}`);

        // 1. –ü—Ä–æ–≤–µ—Ä—è–µ–º —Å—É—â–µ—Å—Ç–≤–æ–≤–∞–Ω–∏–µ –ø–∞–ø–∫–∏ —Å–æ —à—Ä–∏—Ñ—Ç–∞–º–∏
        try {
            await fs.access(CONFIG.FONTS_DIR);
            logger.debug(`Directory exists: ${CONFIG.FONTS_DIR}`);
        } catch {
            logger.warn(`Fonts directory not found: ${CONFIG.FONTS_DIR}`);
            logger.info("Attempting to create directory...");
            await fs.mkdir(CONFIG.FONTS_DIR, { recursive: true });
            logger.success(`Created empty directory: ${CONFIG.FONTS_DIR}`);
            logger.info("Add font files and rerun the script.");
            return;
        }

        // 2. –†–∞—Å—à–∏—Ä–µ–Ω–Ω—ã–π –ø–æ–∏—Å–∫ —Ñ–∞–π–ª–æ–≤ —à—Ä–∏—Ñ—Ç–æ–≤
        logger.info("Scanning for font files...");
        const patterns = CONFIG.SUPPORTED_EXTENSIONS.map((ext) => `${CONFIG.FONTS_DIR}/**/*${ext}`);
        logger.debug(`Search patterns:\n${patterns.join("\n")}`);

        const fontFiles = (await Promise.all(patterns.map((pattern) => glob(pattern, { nodir: true, caseInsensitiveMatch: true })))).flat();

        logger.debug(`All found files:\n${fontFiles.map((f) => `- ${f}`).join("\n")}`);

        if (fontFiles.length === 0) {
            logger.warn(`No font files found in: ${CONFIG.FONTS_DIR}`);
            logger.info(`Supported extensions: ${CONFIG.SUPPORTED_EXTENSIONS.join(", ")}`);

            // –î–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω–∞—è –ø—Ä–æ–≤–µ—Ä–∫–∞: –ø–æ–∫–∞–∂–µ–º –ª—é–±—ã–µ —Ñ–∞–π–ª—ã –≤ –ø–∞–ø–∫–µ
            const allFiles = await glob(`${CONFIG.FONTS_DIR}/**/*`);
            if (allFiles.length > 0) {
                logger.info(`Actual files in directory:\n${allFiles.map((f) => `- ${f}`).join("\n")}`);
            }
            return;
        }

        logger.success(`Found ${fontFiles.length} font file(s)`);

        // 3. –ü–∞—Ä—Å–∏–Ω–≥ –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–∏ –æ —à—Ä–∏—Ñ—Ç–∞—Ö
        const fontFaces = [];
        const uniqueFonts = new Set();

        for (const filePath of fontFiles) {
            try {
                const fontData = parseFontData(filePath);
                if (!fontData) continue;

                const fontKey = `${fontData.family}-${fontData.weight}-${fontData.style}`;
                if (uniqueFonts.has(fontKey)) {
                    logger.debug(`Skipping duplicate: ${fontKey}`);
                    continue;
                }

                uniqueFonts.add(fontKey);
                fontFaces.push(generateFontFaceRule(fontData));

                logger.debug(`Processed: ${path.basename(filePath)} ‚Üí ${fontKey}`);
            } catch (err) {
                logger.error(`Error processing ${filePath}: ${err.message}`);
            }
        }

        // 4. –ì–µ–Ω–µ—Ä–∞—Ü–∏—è SCSS-–∫–æ–¥–∞
        if (fontFaces.length === 0) {
            logger.error("No valid font faces generated. Check file naming conventions.");
            return;
        }

        const scssContent = `// Auto-generated by fontface-generator.js
// Generated at: ${new Date().toISOString()}
// DO NOT EDIT MANUALLY!

${fontFaces.join("\n\n")}
`;

        // 5. –°–æ–∑–¥–∞–µ–º –ø–∞–ø–∫—É –¥–ª—è –≤—ã—Ö–æ–¥–Ω–æ–≥–æ —Ñ–∞–π–ª–∞
        const outputDir = path.dirname(CONFIG.OUTPUT_FILE);
        try {
            await fs.mkdir(outputDir, { recursive: true });
            logger.debug(`Created output directory: ${outputDir}`);
        } catch (err) {
            logger.error(`Failed to create output directory: ${err.message}`);
            throw err;
        }

        // 6. –ó–∞–ø–∏—Å—ã–≤–∞–µ–º —Ñ–∞–π–ª
        await fs.writeFile(CONFIG.OUTPUT_FILE, scssContent, "utf-8");
        logger.success(`Successfully generated ${fontFaces.length} @font-face rules`);
        logger.info(`Output file: ${CONFIG.OUTPUT_FILE}`);
    } catch (err) {
        logger.error(`Fatal error: ${err.message}`);
        if (process.env.DEBUG) {
            console.error(err.stack);
        }
        process.exit(1);
    }
}

// --- –í—Å–ø–æ–º–æ–≥–∞—Ç–µ–ª—å–Ω—ã–µ —Ñ—É–Ω–∫—Ü–∏–∏ ---
function parseFontData(filePath) {
    const fileName = path.basename(filePath);
    const ext = path.extname(filePath).toLowerCase();
    const baseName = fileName.slice(0, -ext.length);

    logger.debug(`Parsing font: ${fileName}`);

    // –ü–∞—Ä—Å–∏–º –∏–º—è —Ñ–∞–π–ª–∞ (–ø—Ä–∏–º–µ—Ä: "Inter-SemiBoldItalic" => { family: "Inter", weight: 600, style: "italic" })
    const WEIGHT_MAP = {
        thin: 100,
        hairline: 100,
        extralight: 200,
        ultralight: 200,
        light: 300,
        regular: 400,
        normal: 400,
        medium: 500,
        semibold: 600,
        demibold: 600,
        bold: 700,
        extrabold: 800,
        ultrabold: 800,
        black: 900,
        heavy: 900,
    };

    let family = baseName;
    let weight = 400;
    let style = "normal";

    // –ò—â–µ–º –≤ –Ω–∞–∑–≤–∞–Ω–∏–∏ —É–∫–∞–∑–∞–Ω–∏–µ –≤–µ—Å–∞
    for (const [key, value] of Object.entries(WEIGHT_MAP)) {
        const regex = new RegExp(`-${key}`, "i");
        if (regex.test(family)) {
            weight = value;
            family = family.replace(regex, "");
            break;
        }
    }

    // –ü—Ä–æ–≤–µ—Ä—è–µ–º –Ω–∞ italic/oblique
    const italicRegex = /-(italic|oblique)/i;
    if (italicRegex.test(family)) {
        style = "italic";
        family = family.replace(italicRegex, "");
    }

    // –£–¥–∞–ª—è–µ–º –æ—Å—Ç–∞–≤—à–∏–µ—Å—è –º–æ–¥–∏—Ñ–∏–∫–∞—Ç–æ—Ä—ã (–Ω–∞–ø—Ä–∏–º–µ—Ä, "Condensed")
    family = family.replace(/-(condensed|narrow|wide|expanded)/i, "");

    // –§–æ—Ä–º–∏—Ä—É–µ–º –æ—Ç–Ω–æ—Å–∏—Ç–µ–ª—å–Ω—ã–π –ø—É—Ç—å (–∏–∑ public/)
    const relativePath = "/" + path.relative(path.join(process.cwd(), "public"), filePath).replace(/\\/g, "/"); // –î–ª—è Windows

    return {
        family: family.trim() || "UnknownFont",
        weight,
        style,
        format: getFontFormat(ext),
        relativePath,
        fileName,
    };
}

function generateFontFaceRule(fontData) {
    return `@font-face {
  font-family: '${fontData.family}';
  src: url('${fontData.relativePath}') format('${fontData.format}');
  font-weight: ${fontData.weight};
  font-style: ${fontData.style};
  font-display: ${CONFIG.DEFAULT_FONT_PROPS.display};${CONFIG.DEFAULT_FONT_PROPS.unicodeRange ? `\n  unicode-range: ${CONFIG.DEFAULT_FONT_PROPS.unicodeRange};` : ""}
}`;
}

function getFontFormat(ext) {
    const FORMAT_MAP = {
        ".woff2": "woff2",
        ".woff": "woff",
        ".ttf": "truetype",
        ".otf": "opentype",
    };
    return FORMAT_MAP[ext] || ext.replace(".", "");
}

// --- –ó–∞–ø—É—Å–∫ ---
generateFontFaces();
